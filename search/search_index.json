{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>ProGuardCORE is a free library to read, analyze, modify, and write Java class files. It is the core of the well-known shrinker, optimizer, and obfuscator ProGuard and of the ProGuard Assembler and Disassembler.</p> <p>Typical applications:</p> <ul> <li>Perform peephole optimizations in Java bytecode.</li> <li>Search for instruction patterns.</li> <li>Analyze code with abstract evaluation.</li> <li>Optimize and obfuscate, like ProGuard itself.</li> </ul>"},{"location":"index.html#design","title":"Design","text":"<p>The library defines many small classes as the building blocks for applications that contain the processing logic. This is sometimes taken to the extreme: even loops and conditional statements can often be implemented as separate classes. Even though these classes are verbose and repetitive, the resulting main code becomes much more compact, flexible, and robust.</p>"},{"location":"index.html#data-classes","title":"Data classes","text":"<p>Basic data classes define the structures to represent Java bytecode. They reflect the Java bytecode specifications literally, to ensure that no data are lost when reading, analyzing, and writing them. The data classes contain only a minimum number of methods. They do have one or more accept methods to let the visitor classes below operate on them.</p>"},{"location":"index.html#visitor-classes","title":"Visitor classes","text":"<p>The library applies the visitor pattern extensively. Visitor classes define the operations on the data: reading, writing, editing, transforming, analyzing, etc. The visitor classes have one or more 'visit' methods to operate on data classes of the same basic type.</p> <p>For example, a Java bytecode class contains a constant pool with constants of different types: integer constants, float constants, string constants, etc. The data classes IntegerConstant, FloatConstant, StringConstant, etc. all implement the basic type Constant. The visitor interface ConstantVisitor contains methods 'visitIntegerConstant', 'visitFloatConstant', 'visitStringConstant', etc. Implementations of this visitor interface can perform all kinds of operations on the constants.</p> <p>The reasoning behind this pattern is that the data classes are very stable, because they are directly based on the bytecode specifications. The operations are more dynamic, since they depend on the final application. It is practically impossible to add all possible operations in the data classes, but it is easy to add another implementation of a visitor interface. Implementing an interface in practice helps a lot to think of all possible cases.</p> <p>The visitor pattern uses visitor interfaces to operate on the similar elements of a data structure. Each interface often has many implementations. A great disadvantage at this time is that visitor methods can invoke one another (directly or indirectly), but they can't communicate easily. Since the implementations can't add their own parameters or return values, they often have to rely on fields to pass values back and forth. This is more error-prone. Still, the advantages of the visitor pattern outweigh the disadvantages.</p>"},{"location":"index.html#dependency-injection","title":"Dependency injection","text":"<p>The library classes heavily use constructor-based dependency injection, to create immutable instances. Notably the visitor classes are often like commands that are combined in an immutable structure, via constructors. You can execute such commands by applying the visitors to the data classes.</p>"},{"location":"index.html#api","title":"API","text":"<p>You can find the complete API in the ProGuardCORE javadoc.</p>"},{"location":"building.html","title":"Building","text":"<p>If you've downloaded the source code of the ProGuardCORE library, you can build it yourself with Gradle:</p> <ul> <li> <p>Build the artifacts:</p> <pre><code>./gradlew assemble\n</code></pre> </li> <li> <p>Publish the artifacts to your local Maven cache (something like <code>~/.m2/</code>):</p> <pre><code>./gradlew publishToMavenLocal\n</code></pre> </li> <li> <p>Build tar and zip archives with the binaries and documentation:</p> <pre><code>./gradlew distTar distZip\n</code></pre> </li> <li> <p>Build the complete API documentation with</p> <pre><code>./gradlew javadoc\n</code></pre> </li> </ul> <p>You can then find the API documentation in <code>docs/md/api</code>.</p>"},{"location":"creating.html","title":"Creating classes","text":"<p>The easiest way to create a new class from scratch is with ClassBuilder. It provides a fluent API to add fields and methods. For example, to create a class that prints out \"Hello, world!\":</p> <pre><code>ProgramClass programClass =\nnew ClassBuilder(\nVersionConstants.CLASS_VERSION_1_8,\nAccessConstants.PUBLIC,\n\"HelloWorld\",\nClassConstants.NAME_JAVA_LANG_OBJECT)\n\n.addMethod(\nAccessConstants.PUBLIC |\nAccessConstants.STATIC,\n\"main\",\n\"([Ljava/lang/String;)V\",\n50,\n\ncode -&gt; code\n.getstatic(\"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\")\n.ldc(\"Hello, world!\")\n.invokevirtual(\"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\")\n.return_())\n\n.getProgramClass();\n</code></pre> <p>You can also use it to add fields and methods to an existing class:</p> <pre><code>ProgramClass programClass =\nnew ClassBuilder(existingClass)\n.....\n</code></pre> <p>Complete example: CreateHelloWorldClass.java</p>"},{"location":"downloads.html","title":"Downloads","text":"<p>The ProGuardCORE library is distributed under the terms of the Apache License Version 2.0. Please consult the license page for more details.</p> <p>ProGuardCORE is written in Java, so it requires a Java Runtime Environment (JRE 1.8 or higher).</p> <p>You can download the library in various forms:</p> <ul> <li> <p>Pre-built artifacts at Maven Central</p> <pre><code>dependencies {\ncompile project(':com.guardsquare:proguard-core:9.0.0')\n}\n</code></pre> <p>or</p> <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.guardsquare&lt;/groupId&gt;\n&lt;artifactId&gt;proguard-core&lt;/artifactId&gt;\n&lt;version&gt;9.0.0&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> </li> <li> <p>A Git repository of the source code at Github</p> <pre><code>git clone https://github.com/Guardsquare/proguard-core.git\n</code></pre> </li> </ul> <p>You can find major releases, minor releases with important bug fixes, and beta releases with the latest new features and any less urgent bug fixes.</p> <p>If you're still working with an older version of the library, check out the release notes, to see if you're missing something essential.</p>"},{"location":"editing.html","title":"Editing classes","text":""},{"location":"editing.html#editing-classes","title":"Editing classes","text":"<p>You can edit existing classes with ClassEditor and related editors like InterfacesEditor, AttributesEditor, and ConstantPoolEditor.</p> <pre><code>ClassEditor classEditor =\nnew ClassEditor(targetClass);\n\nclassEditor.addField(field);\n\nclassEditor.addMethod(method);\n</code></pre> <p>If you want to create and add new fields or methods from scratch, you can use the more convenient ClassBuilder:</p> <pre><code>ProgramClass programClass =\nnew ClassBuilder(existingClass)\n.addField(\nAccessConstants.PUBLIC |\nAccessConstants.STATIC,\n\"someField\",\nTypeConstants.INT);\n\n.addMethod(\nAccessConstants.PUBLIC |\nAccessConstants.STATIC,\n\"main\",\n\"([Ljava/lang/String;)V\",\n50,\n\ncode -&gt; code\n.getstatic(\"java/lang/System\", \"out\", \"Ljava/io/PrintStream;\")\n.ldc(\"Hello, world!\")\n.invokevirtual(\"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\")\n.return_())\n\n.getProgramClass();\n</code></pre>"},{"location":"editing.html#editing-code","title":"Editing code","text":"<p>Perhaps more interestingly, you can edit the bytecode of method bodies with CodeAttributeEditor.</p> <pre><code>CodeAttributeEditor codeAttributeEditor =\nnew CodeAttributeEditor();\n\nInstructionSequenceBuilder builder =\nnew InstructionSequenceBuilder(targetClass);\n\nInstructions[] replacementInstructions = builder\n.getstatic(\"java/lang/System\", \"out\", \"Ljava/io/\n    .ldc(\"Hello\")\n    .invokevirtual(\"java/io/PrintStream\", \"println\", \"(Ljava/lang/String;)V\"        \n    .instructions();\n\n// Prepare the editor for this code.\ncodeAttributeEditor.reset(codeAttribute.u4codeLength);\n\n// Insert the instruction sequence before a specified offset.\ncodeAttributeEditor.insertBeforeOffset(offset, replacementInstructions);\n\n// Apply the changes.\ncodeAttributeEditor.visitCodeAttribute(clazz, method, codeAttribute);\n</code></pre>"},{"location":"kotlin.html","title":"Kotlin metadata","text":"<p>The library makes it easy to read, write and modify the Kotlin metadata that is attached to Java classes. The following example prints all the names of Kotlin functions in the metadata attached to the Java class <code>Foo</code>:</p> <pre><code>programClassPool.classesAccept(\nnew ClassNameFilter(\"Foo\",\nnew ReferencedKotlinMetadataVisitor(\nnew AllFunctionsVisitor(\n(clazz, container, function) -&gt; System.out.println(function.name)))));\n</code></pre>"},{"location":"kotlin.html#initializing-the-kotlin-metadata-model","title":"Initializing the Kotlin metadata model","text":"<p>There are two ways to initialize the Kotlin metadata model:</p> <ul> <li>While reading classes with <code>ClassReader</code> by setting <code>includeKotlinMetadata</code> to <code>true</code>.</li> <li>After class reading using <code>KotlinMetadataInitializer</code>.</li> </ul>"},{"location":"kotlin.html#kotlinmetadatainitializer","title":"<code>KotlinMetadataInitializer</code>","text":"<p>The <code>KotlinMetadataInitializer</code> can be used as a <code>ClassVisitor</code> which will read the Kotlin metadata from the <code>kotlin.Metadata</code> annotation on program classes (<code>ProgramClass</code>) and  automatically initialize the metadata model on visited classes:</p> <pre><code>BiConsumer&lt;Clazz, String&gt; errorHandler = (clazz, message) -&gt; System.err.println(message);\nprogramClassPool.classesAccept(new KotlinMetadataInitializer(errorHandler));\n</code></pre> <p>Alternatively, the <code>initialize(Clazz, int, int[], String[], String[], int, String, String)</code> can be called directly with a <code>Clazz</code> and the components making up the <code>kotlin.Metadata</code> annotation:</p> <pre><code>BiConsumer&lt;Clazz, String&gt; errorHandler\n= (clazz, message) -&gt; System.err.println(message);\nKotlinMetadataInitializer initializer\n= new KotlinMetadataInitializer(errorHandler);\nprogramClassPool.classesAccept(\nclazz -&gt; {\n// get the values for k, mv, d1, d2, xi, xs, pn to provide to the initializer\ninitializer.initialize(clazz, k, mv, d1, d2, xi, xs, pn);\n}\n);\n</code></pre> <p>This is useful for initializing the model on library classes (<code>LibraryClass</code>), since the library class model doesn't contain  all the necessary information to automatically extract these parameters.</p>"},{"location":"kotlin.html#initializing-references","title":"Initializing references","text":"<p>Once the model itself is initialized by <code>KotlinMetadataInitializer</code>, like the <code>Clazz</code> model, references must be initialized. This is done by the <code>ClassReferenceInitializer</code>:</p> <pre><code>// First build the model\nBiConsumer&lt;Clazz, String&gt; errorHandler = (clazz, message) -&gt; System.err.println(message);\nprogramClassPool.classesAccept(new KotlinMetadataInitializer(errorHandler));\n// Then initialize the references\nprogramClassPool.classesAccept(\nnew ClassReferenceInitializer(programClassPool, libraryClassPool)\n);\n</code></pre>"},{"location":"license.html","title":"License","text":"<p>The ProGuardCORE library is licensed under the Apache License Version 2.0.</p> <p>Copyright 2002-2020 Guardsquare NV</p> <pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p>"},{"location":"partialevaluator.html","title":"Data flow analysis with partial evaluation","text":""},{"location":"partialevaluator.html#analyzing-all-instructions","title":"Analyzing all instructions","text":"<p>If you want to analyze bytecode, you'll probably want to visit specified instructions of specified code attributes of specified methods of specified classes. The visitor classes and filters quickly get you to the right place:</p> <pre><code>programClassPool.classesAccept(\nnew AllMethodVisitor(\nnew AllAttributeVisitor(\nnew AllInstructionVisitor(\nnew MyInstructionAnalyzer()))));\n</code></pre> <p>You then only need to implement the visitor methods to analyze the instructions:</p> <pre><code>class      MyInstructionAnalyzer\nimplements InstructionVisitor\n{\npublic void visitSimpleInstruction(Clazz clazz, .....) ...\npublic void visitVariableInstruction(Clazz clazz, .....) ...\npublic void visitConstantInstruction(Clazz clazz, .....) ...\npublic void visitBranchInstruction(Clazz clazz, .....) ...\npublic void visitTableSwitchInstruction(Clazz clazz, .....) ...\npublic void visitLookUpSwitchInstruction(Clazz clazz, .....) ...\n}\n</code></pre> <p>The library already provides classes to analyze the code for you, finding branching information, performing partial evaluation, finding the control flow and data flow, etc, as introduced in the following sections.</p> <p>Complete example: EvaluateReturnValues.java</p>"},{"location":"partialevaluator.html#branching","title":"Collecting basic branching information","text":"<p>You can extract basic information about branches in a method with the class BranchTargetFinder. The results are defined at the instruction level: each instruction is properly labeled as a branch target, branch origin, exception handler, etc.</p> <pre><code>BranchTargetFinder branchTargetFinder =\nnew BranchTargetFinder();\n\nbranchTargetFinder.visitCodeAttribute(clazz, method, codeAttribute);\n\nif (branchTargetFinder.isBranchOrigin(offset)) ...\n\nif (branchTargetFinder.isBranchTarget(offset)) ...\n</code></pre> <p>Complete example: ApplyPeepholeOptimizations.java</p>"},{"location":"partialevaluator.html#partial-evaluation","title":"Partial evaluation","text":"<p>You can extract more information about the code with partial evaluation (often called abstract evaluation or symbolic evaluation). Its analysis provides a global view of the control flow and data flow in a method.</p> <p>The core class is PartialEvaluator. It can work at different levels of precision \u2014 the more abstract, the less precise. You can control the precision with different value factories and different invocation units:</p> <ul> <li> <p>A ValueFactory defines the level of detail in representing values like   integers or reference types. The values can be very abstract (any primitive   integer, a reference to any object) or more precise (the integer 42, or an   integer between 0 and 5, or a non-null reference to an instance of   java/lang/String).</p> </li> <li> <p>An InvocationUnit defines the values returned from retrieved fields and   invoked methods. The values can again be very generic (any integer) or they   can also be values that were cached in prior evaluations of the code base.</p> </li> </ul> <p>Complete example: EvaluateCode.java, which provides options to analyze code with different levels of precision. It prints out its results in markdown format, which is also used in the examples below.</p>"},{"location":"partialevaluator.html#control-flow-analysis","title":"Control flow analysis","text":"<p>You can set up basic evaluation with a BasicValueFactory and a BasicInvocationUnit:</p> <pre><code>ValueFactory     valueFactory     = new BasicValueFactory();\nInvocationUnit   invocationUnit   = new BasicInvocationUnit(valueFactory);\nPartialEvaluator partialEvaluator = new PartialEvaluator(valueFactory,\ninvocationUnit,\nfalse);\n</code></pre> <p>The analysis provides a control flow graph of the instructions in a method. Each instruction is labeled with potential branch targets and branch origins:</p> <pre><code>InstructionOffsetValue branchOrigins = partialEvaluator.branchOrigins(offset));\nInstructionOffsetValue branchTargets = partialEvaluator.branchTargets(offset));\n</code></pre> <p>Complete example: VisualizeControlFlow.java</p>"},{"location":"partialevaluator.html#data-flow-analysis","title":"Data flow analysis","text":"<p>You can also inspect the data flow between the instructions in a method by looking at the stack and the local variables:</p> <pre><code>TracedStack     stack     = partialEvaluator.getStackAfter(offset);\nTracedVariables variables = partialEvaluator.getVariablesAfter(offset);\n</code></pre> <p>Consider the following code:</p> <pre><code>public static int getAnswer()\n{\nint f1 = 6;\nint f2 = 7;\n\nreturn f1 * f2;\n}\n</code></pre> <p>Applying the above partial evaluator to this code yields this overall result:</p> Instruction Stack v0 v1 [0] bipush 6 [0:i] empty empty [2] istore_0 v0 2:i empty [3] bipush 7 [3:i] 2:i empty [5] istore_1 v1 2:i 5:i [6] iload_0 v0 [6:i] 2:i 5:i [7] iload_1 v1 [6:i] [7:i] 2:i 5:i [8] imul [8:i] 2:i 5:i [9] ireturn 2:i 5:i <p>Each integer value followed by a colon indicates the offset of the instruction that stored or pushed the value. Each 'i' indicates an unknown primitive integer value.</p> <p>Useful applications: dependency analysis at an instruction level, for example to remove unused instructions.</p> <p>Complete example: EvaluateCode.java</p>"},{"location":"partialevaluator.html#numerical","title":"More precise numerical evaluation","text":"<p>The above basic evaluation doesn't tell you much about any numerical results. You can set up more precise numerical evaluation with a ParticularValueFactory:</p> <pre><code>ValueFactory     valueFactory     = new ParticularValueFactory(new BasicValueFactory());\nInvocationUnit   invocationUnit   = new BasicInvocationUnit(valueFactory);\nPartialEvaluator partialEvaluator = new PartialEvaluator(valueFactory,\ninvocationUnit,\nfalse);\n</code></pre> <p>For the same code as in the previous section:</p> Instruction Stack v0 v1 [0] bipush 6 [0:6] empty empty [2] istore_0 v0 2:6 empty [3] bipush 7 [3:7] 2:6 empty [5] istore_1 v1 2:6 5:7 [6] iload_0 v0 [6:6] 2:6 5:7 [7] iload_1 v1 [6:6] [7:7] 2:6 5:7 [8] imul [8:42] 2:6 5:7 [9] ireturn 2:6 5:7 <p>In this trivial example, the previously unknown integers are now all concrete values. The last instruction pops the computed result 42 from the stack and returns it.</p> <p>Useful application: constant propagation.</p>"},{"location":"partialevaluator.html#range","title":"Evaluation with numeric ranges","text":"<p>Consider the following code:</p> <pre><code>public static int getAnswer()\n{\nint answer = 0;\nfor (int counter = 0; counter &lt; 3 &amp;&amp; Math.random() &lt; 0.5f; counter++)\n{\nanswer += 14;\n}\n\nreturn answer;\n}\n</code></pre> <p>The possible answer isn't a single value. You can let the evaluation work with integer ranges with a RangeValueFactory:</p> <pre><code>ValueFactory     valueFactory     = new RangeValueFactory(new ArrayReferenceValueFactory(), new BasicValueFactory());\nInvocationUnit   invocationUnit   = new BasicInvocationUnit(valueFactory);\nPartialEvaluator partialEvaluator = new PartialEvaluator(valueFactory,\ninvocationUnit,\nfalse);\n</code></pre> <p>The overall result of the analysis of the sample method is:</p> Instruction Stack v0 v1 [0] iconst_0 [0:0] empty empty [1] istore_0 v0 1:0 empty [2] iconst_0 [2:0] 1:0 empty [3] istore_1 v1 1:0 3:0 [4] iload_1 v1 [4:0..3] 1,19:0..42 3,22:0..3 [5] iconst_3 [4:0..3] [5:3] 1,19:0..42 3,22:0..3 [6] if_icmpge +22 (target=28) 1,19:0..42 3,22:0..3 [9] invokestatic #2 [9:T] [9:d] 1,19:0..28 3,22:0..2 [12] ldc2_w #3 [9:T] [9:d] [12:T] [12:0.5d] 1,19:0..28 3,22:0..2 [15] dcmpg [15:i] 1,19:0..28 3,22:0..2 [16] ifge +12 (target=28) 1,19:0..28 3,22:0..2 [19] iinc v0, 14 19:14..42 3,22:0..2 [22] iinc v1, 1 19:14..42 22:1..3 [25] goto -21 (target=4) 19:14..42 22:1..3 [28] iload_0 v0 [28:0..42] 1,19:0..42 3,22:0..3 [29] ireturn 1,19:0..42 3,22:0..3 <p>Not all values are entirely concrete; they can have a range (with \"..\"). The method can return a value between 0 and 42.</p> <p>Useful applications: simplification of range checks.</p>"},{"location":"partialevaluator.html#symbolic","title":"Symbolic numerical evaluation","text":"<p>Consider the following code:</p> <pre><code>private static int getAnswer(int a, int b)\n{\nreturn 2 * a + b;\n}\n</code></pre> <p>The numerical evaluation of the previous sections doesn't get you very far, since the parameters are unknown, so all computations produce unknown values:</p> Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i P1:i [1] iload_0 v0 [0:2] [1:i] P0:i P1:i [2] imul [2:i] P0:i P1:i [3] iload_1 v1 [2:i] [3:i] P0:i P1:i [4] iadd [4:i] P0:i P1:i [5] ireturn P0:i P1:i <p>You can set up symbolic evaluation with an IdentifiedValueFactory:</p> <pre><code>ValueFactory     valueFactory     = new IdentifiedValueFactory();\nInvocationUnit   invocationUnit   = new BasicInvocationUnit(valueFactory);\nPartialEvaluator partialEvaluator = new PartialEvaluator(valueFactory,\ninvocationUnit,\nfalse);\n</code></pre> <p>The overall result of the analysis of the sample method is:</p> Instruction Stack v0 v1 [0] iconst_2 [0:2] P0:i0 P1:i1 [1] iload_0 v0 [0:2] [1:i0] P0:i0 P1:i1 [2] imul [2:(2*i0)] P0:i0 P1:i1 [3] iload_1 v1 [2:(2*i0)] [3:i1] P0:i0 P1:i1 [4] iadd [4:((2*i0)+i1)] P0:i0 P1:i1 [5] ireturn P0:i0 P1:i1 <p>The unknown values now have symbolic names (IDs): \"i0\" and \"i1\". Any computations result in symbolic expressions, such as \"((2*i0)+i1)\".</p> <p>Useful applications: a basis for symbolic simplification, static single assignment, further analysis with SMT solvers (satisfiability modulo theories).</p>"},{"location":"partialevaluator.html#tracing","title":"Evaluation with reference types","text":"<p>The previous sections only showed examples with primitive types. Consider the following code with reference types:</p> <pre><code>public static Number getAnswer(Number answer)\n{\nif (answer == null)\n{\nanswer = new Integer(42);\n}\n\nreturn answer;\n}\n</code></pre> <p>The basic or numeric evaluation of the previuous sections don't tell much about the non-primitive types:</p> Instruction Stack v0 [0] aload_0 v0 [0:a] P0:a [1] ifnonnull +13 (target=14) P0:a [4] new #2 [4:a] P0:a [7] dup [4:7:a] [4:7:a] P0:a [8] bipush 42 [4:7:a] [4:7:a] [8:42] P0:a [10] invokespecial #3 [4:7:a] P0:a [13] astore_0 v0 13:a [14] aload_0 v0 [14:a] P0,13:a [15] areturn P0,13:a <p>Unknown reference types are shown as \"a\".</p> <p>You can keep track of origins of references in more detail with a ReferenceTracingValueFactory and a ReferenceTracingInvocationUnit. The PartialEvaluator is set up slightly differently from the earlier examples:</p> <pre><code>ReferenceTracingValueFactory valueFactory     = new ReferenceTracingValueFactory(new BasicValueFactory()) :\nInvocationUnit               invocationUnit   = new ReferenceTracingInvocationUnit(new BasicInvocationUnit(valueFactory));\nPartialEvaluator             partialEvaluator = new PartialEvaluator(valueFactory,\ninvocationUnit,\nfalse,\nvalueFactory);\n</code></pre> <p>The results then show the origins of non-primitive types:</p> Instruction Stack v0 [0] aload_0 v0 [0:P0:a] P0:P0:a [1] ifnonnull +13 (target=14) P0:P0:a [4] new #2 [4:N4:a] P0:P0:a [7] dup [4:7:N4:a] [4:7:N4:a] P0:P0:a [8] bipush 42 [4:7:N4:a] [4:7:N4:a] [8:i] P0:P0:a [10] invokespecial #3 [4:7:N4:a] P0:P0:a [13] astore_0 v0 13:N4:a [14] aload_0 v0 [14:N4,P0:a] P0,13:N4,P0:a [15] areturn P0,13:N4,P0:a <p>For example, the method pops and returns either a new instance (\"N4\") that was created at offset 4, or parameter 0 (\"P0\").</p> <p>Useful applications: define/use analysis, a basis for escape analysis or taint analysis.</p>"},{"location":"partialevaluator.html#typed","title":"Evaluation with more precise reference types","text":"<p>You can keep track of non-primitive types in more detail with a TypedReferenceValueFactory:</p> <pre><code>ValueFactory     valueFactory     = new TypedReferenceValueFactory();\nInvocationUnit   invocationUnit   = new BasicInvocationUnit(valueFactory);\nPartialEvaluator partialEvaluator = new PartialEvaluator(valueFactory,\ninvocationUnit,\nfalse);\n</code></pre> <p>The results then show the types:</p> Instruction Stack v0 [0] aload_0 v0 [0:Ljava/lang/Number;] P0:Ljava/lang/Number; [1] ifnonnull +13 (target=14) P0:Ljava/lang/Number; [4] new #2 [4:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [7] dup [4:7:Ljava/lang/Integer;=!] [4:7:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [8] bipush 42 [4:7:Ljava/lang/Integer;=!] [4:7:Ljava/lang/Integer;=!] [8:i] P0:Ljava/lang/Number; [10] invokespecial #3 [4:7:Ljava/lang/Integer;=!] P0:Ljava/lang/Number; [13] astore_0 v0 13:Ljava/lang/Integer;=! [14] aload_0 v0 [14:Ljava/lang/Number;] P0,13:Ljava/lang/Number; [15] areturn P0,13:Ljava/lang/Number; <p>The types here are \"Ljava/lang/Number;\" and \"Ljava/lang/Integer;\". The types respect the type hierarchy, for example when the branches join and the type is \"Ljava/lang/Number;\". A mark \"=\" means that the type is the exact type, not an extension. A mark \"!\" means that the value is definitely not null.</p> <p>Useful applications: preverification of the type safety of bytecode.</p>"},{"location":"partialevaluator.html#note-on-type-variables-naming-convention","title":"Note on type variables naming convention","text":"<p>PGC has different representation for type string variables:</p> <ul> <li>External class name: <code>com.guardsquare.SomeClass</code></li> <li>Internal class name: <code>com/guardsquare/SomeClass</code></li> <li>Internal type (or just <code>type</code>): <code>Lcom/guardsquare/SomeClass;</code> (for arrays e.g. <code>[I</code>, <code>[Ljava/lang/Object;</code>)</li> <li>Internal class type: <code>com/guardsquare/SomeClass</code> (for arrays this is their internal type e.g. <code>[I</code>, <code>[Ljava/lang/Object;</code>)</li> </ul> <p>See <code>proguard.classfile.util.ClassUtil</code> for useful methods to convert between the different representations.</p>"},{"location":"partialevaluator.html#array","title":"Evaluation with primitive arrays","text":"<p>Primitive arrays may be of special interest, for example when performing optimizations.</p> <p>Consider the following code:</p> <pre><code>public static int getAnswer()\n{\nint[] array = new int[] { 6, 7 };\n\nreturn array[0] * array[1];\n}\n</code></pre> <p>Even though this is a trivial example, the previous evaluations wouldn't provide much useful information:</p> Instruction Stack v0 [0] iconst_2 [0:i] empty [1] newarray 10 [1:[I?=![i]] empty [3] dup [1:3:[I?=![i]] [1:3:[I?=![i]] empty [4] iconst_0 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] empty [5] bipush 6 [1:3:[I?=![i]] [1:3:[I?=![i]] [4:i] [5:i] empty [7] iastore [1:3:[I?=![i]] empty [8] dup [1:8:[I?=![i]] [1:8:[I?=![i]] empty [9] iconst_1 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] empty [10] bipush 7 [1:8:[I?=![i]] [1:8:[I?=![i]] [9:i] [10:i] empty [12] iastore [1:8:[I?=![i]] empty [13] astore_0 v0 13:[I?=![i] [14] aload_0 v0 [14:[I?=![i]] 13:[I?=![i] [15] iconst_0 [14:[I?=![i]] [15:i] 13:[I?=![i] [16] iaload [16:i] 13:[I?=![i] [17] aload_0 v0 [16:i] [17:[I?=![i]] 13:[I?=![i] [18] iconst_1 [16:i] [17:[I?=![i]] [18:i] 13:[I?=![i] [19] iaload [16:i] [19:i] 13:[I?=![i] [20] imul [20:i] 13:[I?=![i] [21] ireturn 13:[I?=![i] <p>The array type is \"[I\", which is the standard notation for an array of primitive integers.</p> <p>You can keep track of the lengths of arrays with ArrayReferenceValueFactory and even of the contents of primitive arrays with DetailedArrayValueFactory:</p> <pre><code>ValueFactory     valueFactory     = new DetailedArrayValueFactory();\nInvocationUnit   invocationUnit   = new BasicInvocationUnit(valueFactory);\nPartialEvaluator partialEvaluator = new PartialEvaluator(valueFactory,\ninvocationUnit,\nfalse);\n</code></pre> <p>The results of the evaluation then become:</p> Instruction Stack v0 [0] iconst_2 [0:2] empty [1] newarray 10 [1:[I?=![2]#0{6,7}] empty [3] dup [1:3:[I?=![2]#0{6,7}] [1:3:[I?=![2]#0{6,7}] empty [4] iconst_0 [1:3:[I?=![2]#0{6,7}] [1:3:[I?=![2]#0{6,7}] [4:0] empty [5] bipush 6 [1:3:[I?=![2]#0{6,7}] [1:3:[I?=![2]#0{6,7}] [4:0] [5:6] empty [7] iastore [1:3:[I?=![2]#0{6,7}] empty [8] dup [1:8:[I?=![2]#0{6,7}] [1:8:[I?=![2]#0{6,7}] empty [9] iconst_1 [1:8:[I?=![2]#0{6,7}] [1:8:[I?=![2]#0{6,7}] [9:1] empty [10] bipush 7 [1:8:[I?=![2]#0{6,7}] [1:8:[I?=![2]#0{6,7}] [9:1] [10:7] empty [12] iastore [1:8:[I?=![2]#0{6,7}] empty [13] astore_0 v0 13:[I?=![2]#0{6,7} [14] aload_0 v0 [14:[I?=![2]#0{6,7}] 13:[I?=![2]#0{6,7} [15] iconst_0 [14:[I?=![2]#0{6,7}] [15:0] 13:[I?=![2]#0{6,7} [16] iaload [16:6] 13:[I?=![2]#0{6,7} [17] aload_0 v0 [16:6] [17:[I?=![2]#0{6,7}] 13:[I?=![2]#0{6,7} [18] iconst_1 [16:6] [17:[I?=![2]#0{6,7}] [18:1] 13:[I?=![2]#0{6,7} [19] iaload [16:6] [19:7] 13:[I?=![2]#0{6,7} [20] imul [20:42] 13:[I?=![2]#0{6,7} [21] ireturn 13:[I?=![2]#0{6,7} <p>The array is now traced as having length 2 and elements 6 and 7.</p> <p>Useful application: simplification of code with enum types.</p>"},{"location":"partialevaluator.html#particularreference","title":"Evaluation with particular reference values","text":"<p>The values of references can also be of interest.</p> <p>Consider the following code:</p> <pre><code>public StringBuilder append()\n{\nStringBuilder s = new StringBuilder(\"asd\");\ns.append(\"fgh\");\nreturn s;\n}\n</code></pre> <p>If the value of <code>s</code> is of interest, this can be retrieved using a <code>ParticularValueFactory</code>. To also keep track of the references as they flow through method calls (in the example: the constructor-call, and the <code>append</code>), the InvocationUnit needs to be a <code>ExecutingInvocationUnit</code>:</p> <pre><code>ValueFactory            valueFactory     = new ParticularValueFactory(new BasicValueFactory(), new ParticularValueFactory.ReferenceValueFactory());\nExecutingInvocationUnit invocationUnit   = new ExecutingInvocationUnit(valueFactory);\nPartialEvaluator        partialEvaluator = new PartialEvaluator(valueFactory, invocationUnit, false);\n</code></pre> <p>The results of the evaluation then become:</p> Instruction Stack (before the Instruction) v0 (before the Instruction) [0] new StringBuilder [empty:empty] [3] dup [0:StringBuilder=!#0] [empty:empty] [4] ldc \"asd\" [3:0:StringBuilder=!#0][3:0:StringBuilder=!#0] [empty:empty] [6] invokespecial StringBuilder.&lt;init&gt;(String)V [4:String?=#1(asd)][3:0:StringBuilder=!#0][3:0:StringBuilder=!#0] [empty:empty] [9] astore_0 v0 [3:0:StringBuilder=#2(asd)] [empty:empty] [10] aload_0 v0 [9:StringBuilder=#2(asd)] [11] ldc \"fgh\" [10:StringBuilder=#2(asd)] [9:StringBuilder=#2(asd)] [13] invokevirtual StringBuilder.append(String)StringBuilder [11:String?=#3(fgh)][10:StringBuilder=#2(asd)] [9:StringBuilder=#2(asd)] [16] pop [13:StringBuilder=#4(asdfgh)] [13:StringBuilder=#4(asdfgh)] [17] aload_0 v0 [13:StringBuilder=#4(asdfgh)] [18] areturn [17:StringBuilder=#4(asdfgh)] [13:StringBuilder=#4(asdfgh)] <p>(Class/String constants are added to the instruction, and <code>java/lang/</code> is ommited from the class names for clarity)</p> <p>The <code>StringBuilder</code> is now traced through the method, the value of the reference can be retrieved before and after each location. The value of the reference is printed in this output in the finishing brackets. The notation before the bracket is the notation of a <code>TypedReference</code> (TypedReference)</p>"},{"location":"partialevaluator.html#limitations","title":"Limitations","text":"<ul> <li>Only <code>String</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> are currently supported.</li> <li>The <code>ParticularValueFactory</code> keeps track of one specific value of a reference. If more values would be possible (e.g., due to a branch), the result will be an <code>UnknownReferenceValue</code></li> </ul>"},{"location":"partialevaluator.html#lifecycle","title":"Lifecycle","text":"<pre><code>%% [Mermaid Diagramming and charting tool](https://mermaid.js.org/)\nstateDiagram-v2\n    L0: Try\n    state L0 {\n        L1: Evaluate instruction block and branches\n        [*] --&gt; startCodeAttribute\n        startCodeAttribute --&gt; L1\n        state L1 {\n            L2: Evaluate single instruction block\n            [*] --&gt; L2\n            state L2 {\n                L3: For each instruction in block\n                [*] --&gt; startInstructionBlock\n                startInstructionBlock --&gt; L3\n                state L3 {\n                    BR1: Instruction has been seen in this context?\n                    [*] --&gt; BR1\n                    BR1 --&gt; skipInstructionBlock : Yes\n                    skipInstructionBlock --&gt; [*]\n                    BR2: Already evaluated a lot of times?\n                    BR1 --&gt; BR2: No\n                    BR2 --&gt; generalizeInstructionBlock: Yes\n                    generalizeInstructionBlock --&gt; startInstructionEvaluation\n                    BR2 --&gt; startInstructionEvaluation: No\n                    startInstructionEvaluation --&gt; afterInstructionEvaluation\n                    BR3: Branch unit has been called?\n                    afterInstructionEvaluation --&gt; BR3\n                    BR3 --&gt; BR5 : Yes\n                    BR5: #Branch targets &gt; 1?\n                    BR5 --&gt; definitiveBranch: No\n                    BR5 --&gt; registerAlternativeBranch: Yes\n                    registerAlternativeBranch --&gt; registerAlternativeBranch\n                    registerAlternativeBranch --&gt; [*]\n                    definitiveBranch --&gt; BR6\n                    BR6: Instruction was JSR or JSR_W?\n                    BR3 --&gt; BR6 : No\n                    BR_RET: Instruction was RET?\n                    BR6 --&gt; BR_RET\n                    L5: Instruction was subroutine invocation\n                    BR6 --&gt; L5: Yes\n                    state L5 {\n                        [*] --&gt; startSubroutine\n                        recursion1: Evaluate all subroutines\n                        startSubroutine --&gt; recursion1\n                        note left of recursion1: Recursively call back to evaluateInstructionBlockAndExceptionHandlers\n                        recursion1 --&gt; generalizeSubroutine\n                        generalizeSubroutine --&gt; endSubroutine\n                        endSubroutine --&gt; [*]\n                    }\n                    L5 --&gt; [*]\n                    Repeat: Go to next instruction\n                    BR_RET --&gt; Repeat: No\n                    REG_RET: registerSubroutineReturn \n                    BR_RET --&gt; REG_RET: Yes\n                    REG_RET --&gt; [*]\n\n                }\n                L3 --&gt; instructionBlockDone\n                instructionBlockDone --&gt; [*]\n            }\n            L6: For each generated instructionBlock on generated stack\n            L2 --&gt; L6\n            state L6 {\n              evaluateSingleInstructionBlock --&gt; pop\n              pop --&gt; startBranchCodeBlockEvaluation\n              startBranchCodeBlockEvaluation --&gt; evaluateSingleInstructionBlock\n            }\n            L6 --&gt; [*]\n        }\n        L1 --&gt; startExceptionHandlingForBlock\n        L7: For each exception handler registered on code attribute\n      startExceptionHandlingForBlock --&gt; L7\n        state L7 {\n            BR7: Exception handler evaluation is needed?\n            [*] --&gt; BR7\n            BR7 --&gt; registerExceptionHandler: Yes\n            BR7 --&gt; registerUnusedExceptionHandler: No\n            nextExceptionHandler: Go to next exception handler\n            registerExceptionHandler --&gt; evaluateInstructionBlockAndBranches\n            evaluateInstructionBlockAndBranches --&gt; nextExceptionHandler\n            registerUnusedExceptionHandler --&gt; nextExceptionHandler\n        }\n        L7 --&gt; evaluationResults\n        evaluationResults --&gt; [*]\n    }\n    catch: Did catch?\n    L0 --&gt; catch\n    catch --&gt;  [*]: No\n    catch --&gt; registerException: Yes\n  registerException --&gt; [*]</code></pre> <p>The lifecycle can be tracked by providing a <code>PartialEvaluatorStateTracker</code> to the partial evaluator through its builder. For example, when you want to get a JSON debug output regarding the evaluations made by the partial evaluator, you can do so by:</p> <pre><code>JsonPrinter tracker = new JsonPrinter();\nPartialEvaluator partialEvaluator = PartialEvaluator.Builder.create().setStateTracker(tracker).build()\n</code></pre>"},{"location":"patternmatching.html","title":"Pattern matching","text":""},{"location":"patternmatching.html#basic-pattern-matching","title":"Basic pattern matching","text":"<p>The library has powerful support to match patterns in bytecode instruction sequences. You first define the pattern as a sequence of instructions, with wildcards. For example:</p> <pre><code>final int X = InstructionSequenceMatcher.X;\nfinal int C = InstructionSequenceMatcher.C;\n\nInstructionSequenceBuilder ____ =\nnew InstructionSequenceBuilder();\n\nInstruction[] pattern =\n____.iload(X)\n.bipush(C)\n.istore(X).__();\n\nConstant[] constants = ____.constants();\n</code></pre> <p>You can then find that pattern in given code:</p> <pre><code>programClassPool.classesAccept(\nnew AllMethodVisitor(\nnew AllAttributeVisitor(\nnew AllInstructionVisitor(\nnew MyMatchPrinter(\nnew InstructionSequenceMatcher(constants, pattern))))));\n</code></pre> <p>Complete example: ApplyPeepholeOptimizations.java</p>"},{"location":"patternmatching.html#replacing-patterns","title":"Replacing patterns","text":"<p>Instead of just matching instruction sequences, you can also replace matched sequences by other instruction sequences, for example to optimize code or instrument code. The core classes are PeepholeEditor and InstructionSequenceReplacer. Say that you want to replace an instruction sequence \"putstatic/getstatic\" by an equivalent \"dup/putstatic\":</p> <pre><code>final int X = InstructionSequenceReplacer.X;\n\nInstructionSequenceBuilder ____ =\nnew InstructionSequenceBuilder();\n\nInstruction[][] replacements =\n{\n____.putstatic(X)\n.getstatic(X).__(),\n\n____.dup()\n.putstatic(X).__()\n};\n\nConstant[] constants = ____.constants();\n\nBranchTargetFinder  branchTargetFinder  = new BranchTargetFinder();\nCodeAttributeEditor codeAttributeEditor = new CodeAttributeEditor();\n\nprogramClassPool.classesAccept(\nnew AllMethodVisitor(\nnew AllAttributeVisitor(\nnew PeepholeEditor(branchTargetFinder, codeAttributeEditor,\nnew InstructionSequenceReplacer(constants,\nreplacements[0],\nconstants,\nreplacements[1],\nbranchTargetFinder,\ncodeAttributeEditor)))));\n</code></pre> <p>You can define multiple patterns and their respective replacements in one go, with the wrapper InstructionSequencesReplacer.</p> <p>Complete example: ApplyPeepholeOptimizations.java</p>"},{"location":"reading.html","title":"Reading classes","text":""},{"location":"reading.html#streaming-classes-from-a-jar-file","title":"Streaming classes from a jar file","text":"<p>You can read classes from class files and various types of (nested) jar files or jmod files, with some convenient utility classes and visitors. For example, you can read all classes from all jar files in a given directory and print them out in a streaming fashion, while they are read, without collecting their representations:</p> <pre><code>DataEntrySource source =\nnew DirectorySource(\nnew File(inputDirectoryName));\n\nsource.pumpDataEntries(\nnew FilteredDataEntryReader(new DataEntryNameFilter(new ExtensionMatcher(\".jar\")),\nnew JarReader(\nnew ClassFilter(\nnew ClassReader(false, false, false, false, null,\nnew ClassPrinter())))));\n</code></pre> <p>Note the constructor-based dependency injection, to create a chain of visitor classes. We typically use a slightly unconventional indentation to make this construct easy to read.</p> <p>Complete example: PrintClasses.java</p>"},{"location":"reading.html#streaming-classes-from-a-dexapk-file","title":"Streaming classes from a dex/apk file","text":"<p>With the addition of <code>proguard-core-android</code>, you can read classes from dex/apk  files just like you would with jar files. A small example showing how to use  <code>DexClassReader()</code> to read classes from a dex/apk file:</p> <pre><code>DataEntrySource source = new DirectorySource(\nnew File(inputDirectoryName));\n\nDataEntryReader classReader =\nnew NameFilteredDataEntryReader(\"**.class\",\nnew ClassReader(false, false, false, false, null,\nnew ClassNameFilter(\"**\", null)));\n\n// Convert dex files to a jar first\nclassReader =\nnew NameFilteredDataEntryReader(\"classes*.dex\",\nnew DexClassReader(true,\nnew ClassPrinter()),\nclassReader);\n\nsource.pumpDataEntries(classReader);\n</code></pre> <p>Do note that in order to use dex/apk file reading functionalities within  your project, you must import <code>proguard-core-android</code> in the <code>build.gradle</code>  file:</p> <p>build.gradle <pre><code>dependencies {\n  ...\n  implementation project('com.guardsquare:proguard-core')\n  implementation project('com.guardsquare:proguard-core-android')\n  ...\n}\n</code></pre></p> <p>A complete example for reading from dex, apk and jar files can be found in: JarUtil.java</p>"},{"location":"reading.html#writing-out-streamed-classes","title":"Writing out streamed classes","text":"<p>You can read classes, optionally perform some small modifications, and write them out right away, again in a streaming fashion.</p> <pre><code>JarWriter jarWriter =\nnew JarWriter(\nnew ZipWriter(\nnew FixedFileWriter(\nnew File(outputJarFileName))));\n\nDataEntrySource source =\nnew FileSource(\nnew File(inputJarFileName));\n\nsource.pumpDataEntries(\nnew JarReader(\nnew ClassFilter(\nnew ClassReader(false, false, false, false, null,\nnew DataEntryClassWriter(jarWriter)))));\n\njarWriter.close();\n</code></pre> <p>Complete example: ApplyPeepholeOptimizations.java</p>"},{"location":"reading.html#collecting-classes","title":"Collecting classes","text":"<p>Alternatively, you may want to collect the classes in a so-called class pool first, so you can perform more extensive analyses on them:</p> <pre><code>ClassPool classPool = new ClassPool();\n\nDataEntrySource source =\nnew FileSource(\nnew File(jarFileName));\n\nsource.pumpDataEntries(\nnew JarReader(false,\nnew ClassFilter(\nnew ClassReader(false, false, false, false, null,\nnew ClassPoolFiller(classPool)))));\n</code></pre> <p>Complete example: Preverify.java</p>"},{"location":"reading.html#writing-out-a-set-of-classes","title":"Writing out a set of classes","text":"<p>If you've collected a set of classes in a class pool, you can write them out with the same visitors as before.</p> <pre><code>JarWriter jarWriter =\nnew JarWriter(\nnew ZipWriter(\nnew FixedFileWriter(\nnew File(outputJarFileName))));\n\nclassPool.classesAccept(\nnew DataEntryClassWriter(jarWriter));\n\njarWriter.close();\n</code></pre> <p>Complete example: Preverify.java</p>"},{"location":"releasenotes.html","title":"Release notes","text":""},{"location":"releasenotes.html#version-91","title":"Version 9.1","text":""},{"location":"releasenotes.html#improved","title":"Improved","text":"<ul> <li>Added <code>PartialEvaluator</code> JSON output for use with proguard-core-visualizer.</li> <li>Improve <code>PartialEvaluator</code> error messages when enabled with <code>PartialEvaluator.Builder.setPrettyPrinting()</code>.</li> <li>Improve documentation for the <code>PartialEvaluator</code> https://guardsquare.github.io/proguard-core/partialevaluator.html.</li> </ul>"},{"location":"releasenotes.html#bug-fixes","title":"Bug fixes","text":"<ul> <li>Fix <code>UnsupportedOperationException</code> when trying to shrink Kotlin metadata from a lambda function.</li> <li>Change behavior of array index out of bounds during partial evaluation, which is now handled as an unknown value instead of throwing an exception in the partial evaluator method.</li> <li>Fix <code>IllegalArgumentException</code> when joining values with different computational type during value analysis.</li> <li>Fix <code>TypedReferenceValue.generalize()</code> not setting <code>mayBeExtension</code> to true when generalizing to common parent type. For now only available experimentally by setting the system property <code>proguard.pe.newextensiongeneralize</code>.</li> </ul>"},{"location":"releasenotes.html#api-changes","title":"API Changes","text":"<ul> <li>No longer consider Record attributes empty when they have no components in <code>NonEmptyAttributeFilter</code>. (#118)</li> <li>Add new <code>ProguardCoreException</code> subclasses with more specific meanings.</li> </ul>"},{"location":"releasenotes.html#version-9010","title":"Version 9.0.10","text":""},{"location":"releasenotes.html#improved_1","title":"Improved","text":"<ul> <li><code>TaintSink</code> can now be configured with a predicate to filter on which <code>TaintSource</code>s trigger it.</li> <li>Improve performance of <code>DynamicClassReferenceInitializer</code>.</li> <li>Improve performance of <code>DynamicClassMemberReferenceInitializer</code>.</li> </ul>"},{"location":"releasenotes.html#api-changes_1","title":"API changes","text":"<ul> <li>The constructors in <code>JvmInvokeTaintSink</code> are now deprecated, <code>JvmInvokeTaintSink#Builder</code> should be used instead.</li> <li><code>MultiTypedReferenceValue.generalize()</code> now removes the <code>null</code> type from the set of potential types, and sets <code>maybeNull</code> on the other types instead.</li> </ul>"},{"location":"releasenotes.html#version-909","title":"Version 9.0.9","text":""},{"location":"releasenotes.html#kotlin-support","title":"Kotlin support","text":"<ul> <li>Add support for processing Kotlin 1.9 metadata.</li> <li>Update <code>kotlinx</code> metadata dependency to version 0.6.0.</li> </ul>"},{"location":"releasenotes.html#java-support","title":"Java support","text":"<ul> <li>Update maximum supported Java class version to 65.65535 (Java 21).</li> </ul>"},{"location":"releasenotes.html#improved_2","title":"Improved","text":"<ul> <li>Added support for adding line numbers in the <code>CodeAttributeEditor</code>.</li> <li>Improve performance of <code>ClassReferenceInitializer</code> when initializing Kotlin type aliases.</li> <li>Improve performance of <code>ClassPool.removeClass</code>.</li> <li>Allow more configuration of <code>ExecutingInvocationUnit</code> by using <code>ExecutingInvocationUnit.Builder</code>.</li> <li>Add a mode to <code>ExecutingInvocationUnit</code> to approximate reference of types not supported for the execution via reflection.</li> <li>Implement <code>Autocloseable</code> in <code>DataEntryWriter</code> interface.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_1","title":"Bug fixes","text":"<ul> <li>Use program location as hash code for <code>JvmAbstractState</code> to allow correct use with hash sets.</li> <li>Fix a bug in <code>JvmTransferRelation</code> handling arithmetic instructions returning category 2 values incorrectly.</li> <li>Fix delegation of <code>proguard.evaluation.value.ParticularValueFactory#createReferenceValueNull()</code>.</li> </ul>"},{"location":"releasenotes.html#api-changes_2","title":"API changes","text":"<ul> <li>The key used for fields in <code>JvmAbstractState</code> has been updated to include the field type to disambiguate between    overloaded fields.</li> <li>Replace <code>allNodes</code> field in <code>proguard.analysis.cpa.defaults.Cfa</code> with <code>getAllNodes</code> method to save memory.</li> <li>Constructor for <code>ExecutingInvocationUnit</code> is deprecated, use <code>ExecutingInvocationUnit.Builder</code> instead.</li> </ul>"},{"location":"releasenotes.html#version-908","title":"Version 9.0.8","text":""},{"location":"releasenotes.html#improved_3","title":"Improved","text":"<ul> <li>Increase <code>proguard.classfile.VersionConstants.MAX_SUPPORTED_VERSION</code> to <code>64.65535</code> (Java 20 + preview enabled).</li> <li>Fix tracking of <code>IdentifiedReferenceValue</code> IDs.</li> <li>Add new Kotlin visitor SAM interfaces: <code>KotlinClassVisitor</code>, <code>KotlinFileFacadeVisitor</code>,   <code>KotlinMultiFileFacadeVisitor</code>, <code>KotlinMultiFilePartVisitor</code>, <code>KotlinSyntheticClassVisitor</code>.</li> </ul>"},{"location":"releasenotes.html#api-changes_3","title":"API changes","text":"<ul> <li><code>JvmTransferRelation</code> has been refactored to model <code>IINC</code> in a separate <code>computeIncrement</code> method. </li> <li>The <code>ProcessingFlag.DONT_PROCESS_KOTLIN_MODULE</code> value was changed from <code>0x00002000</code> to <code>0x00008000</code>.</li> <li>Remove <code>fromClassPool</code> suffixes in <code>CfaUtil</code> methods.</li> <li>Refactor <code>CodeLocation</code> to only take the signature and offset into consideration.</li> <li><code>IdentifiedReferenceValue</code> <code>id</code> field changed from <code>int</code> to <code>Object</code>.</li> <li><code>ParticularValueFactory.ReferenceFactory</code> replaced by <code>ParticularReferenceValueFactory</code>.</li> <li>Add <code>ValueFactory.createReferenceValue(String type, Clazz referencedClass, boolean mayBeExtension, boolean maybeNull, Clazz   creationClass, Method  creationMethod, int creationOffset)</code> to allow creating references identified by their creation site.</li> <li>Add <code>JvmCfaReferenceValueFactory</code> to create references identified by the <code>JvmCfaNode</code> creation site.</li> </ul>"},{"location":"releasenotes.html#upgrade-considerations","title":"Upgrade considerations","text":"<p>Identified and particular references can now be identified by any <code>Object</code> instead of a simple <code>int</code>.  However, this means that code which compared the IDs may need to be modified. For example, the following code should be changed:</p> <pre><code>    public static boolean equal(IdentifiedReferenceValue a, IdentifiedReferenceValue b) {\nreturn a.id == b.id;\n}\n</code></pre> <p>It should use the <code>equals</code> method instead.</p> <pre><code>    public static boolean equal(IdentifiedReferenceValue a, IdentifiedReferenceValue b) {\nreturn a.id.equals(b.id);\n}\n</code></pre> <p>The <code>ParticularReferenceValueFactory</code> identifies references with integers by default:</p> <pre><code>ValueFactory valueFactory = new ParticularReferenceFactory(new ParticularReferenceValueFactory());\nValue a = valueFactory.createReferenceValue(\"Ljava/lang/String;\", clazz, false, false);\n// a.id will be an integer.\n</code></pre> <p>Any <code>Object</code> can be used as an ID using the <code>createReferenceValueForId</code> method:</p> <pre><code>String objectId = \"myId\";\nValueFactory valueFactory = new ParticularReferenceFactory(new ParticularReferenceValueFactory());\nValue a = valueFactory.createReferenceValueForId(\"Ljava/lang/String;\", clazz, false, false, objectId);\n// a.id will be objectId\n</code></pre>"},{"location":"releasenotes.html#version-907","title":"Version 9.0.7","text":""},{"location":"releasenotes.html#improved_4","title":"Improved","text":"<ul> <li>Add <code>JvmShallowHeapModel</code> for selective heap modeling.</li> </ul>"},{"location":"releasenotes.html#version-907_1","title":"Version 9.0.7","text":""},{"location":"releasenotes.html#improved_5","title":"Improved","text":"<ul> <li>Don't report warnings for missing Kotlin default implementation classes when initializing with <code>ClassReferenceInitializer</code>.</li> <li>Only link matching methods in Kotlin file facades with <code>MethodLinker</code>.</li> <li>Extend the <code>LimitedHashMap</code> parameterization with an element exclusion selector.</li> <li>Add the possibility to add a predicate to taint sources and sinks for selective response to calls.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>Fix the reduce operator producing a wrong <code>JvmAbstractState</code> for the composite taint analysis.</li> <li>Fix potential <code>expected Precise Reference</code> runtime verifier error.</li> <li>Don't report warnings for missing Kotlin default implementation classes when initiazing with <code>ClassReferenceInitializer</code>.</li> </ul>"},{"location":"releasenotes.html#api-improvements","title":"API Improvements","text":"<ul> <li>Add <code>KotlinMetadataAsserter</code> to check the integrity of Kotlin metadata.</li> <li>Add <code>JvmReturnTaintSink</code> to support return instruction sinks in taint analysis.</li> <li>Use method signatures instead of fully qualified names in taint sources and sinks.</li> </ul>"},{"location":"releasenotes.html#api-changes_4","title":"API changes","text":"<ul> <li><code>JvmTaintSink</code> has been generalized, use <code>JvmInvokeTaintSink</code> to have the old functionalities.</li> </ul>"},{"location":"releasenotes.html#version-906","title":"Version 9.0.6","text":""},{"location":"releasenotes.html#improved_6","title":"Improved","text":"<ul> <li>Add support for limiting the size of the CPA tree heap model with <code>LimitedHashMap</code>s.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_3","title":"Bug fixes","text":"<ul> <li>Fix <code>ldc_w</code> method in the <code>InstructionSequenceBuilder</code> generating a <code>ldc</code> instruction instead of a <code>ldc_w</code>.</li> </ul>"},{"location":"releasenotes.html#api-improvements_1","title":"API Improvements","text":"<ul> <li>Add <code>referencedDefaultMethodAccept</code> to <code>KotlinFunctionMetadata</code> model.</li> </ul>"},{"location":"releasenotes.html#version-905","title":"Version 9.0.5","text":""},{"location":"releasenotes.html#improved_7","title":"Improved","text":"<ul> <li>Replace <code>proguard-assembler</code> dependency in test fixtures with Maven Central version.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_4","title":"Bug fixes","text":"<ul> <li>Do not add interprocedural CFA edges for methods missing intraprocedural CFA.</li> </ul>"},{"location":"releasenotes.html#version-904","title":"Version 9.0.4","text":""},{"location":"releasenotes.html#improved_8","title":"Improved","text":"<ul> <li>Allow class sub-hierarchy re-initialization for the optimized implementation of <code>ClassSubHierarchyInitializer</code>.</li> <li>Enable providing distinct abort operators for the main and trace reconstruction CPAs.</li> <li>Add a heap model for taint CPA supporting tainting of whole objects.</li> <li><code>Call</code> API: Add a few utilities and fix inconsistent call argument count getter behavior.</li> <li>Only change the Kotlin metadata version if the original version is unsupported.</li> <li>Add support for Kotlin context receivers in Kotlin metadata.</li> <li>Add support for reading &amp; writing Kotlin 1.8 metadata.</li> </ul>"},{"location":"releasenotes.html#api-improvements_2","title":"API Improvements","text":"<ul> <li>Add <code>referencedDefaultImplementationMethodAccept</code> to <code>KotlinFunctionMetadata</code> model class.</li> <li>Deprecated <code>referencedMethodAccept(Clazz, MemberVisitor)</code> in favour of <code>referencedMethodAccept(MemberVisitor)</code> in <code>KotlinFunctionMetadata</code> model class.</li> <li>Add <code>TransformedStringMatcher</code>.</li> <li>Add <code>ClassFeatureNameCollector</code>.</li> <li>Add var-arg constructor to <code>ClassPath</code>.</li> <li>Add <code>DataEntryClassInfoFilter</code>.</li> <li>Add <code>NamedDataEntry</code>.</li> <li>Refactor <code>CodeLocation#getClassName</code> as <code>getExternalClassName</code> to comply with the types naming convention.</li> <li>Make <code>TypedReferenceValue.ALLOW_INCOMPLETE_CLASS_HIERARCHY</code> private, add a getter <code>TypedReferenceValue.allowsIncompleteClassHierarchy()</code> instead.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_5","title":"Bug fixes","text":"<ul> <li>Fix side effect on <code>DetailedArrayReferenceValue</code> modifying values at previous offsets on array store   instructions during <code>PartialEvaluator</code> execution.</li> <li>Fix <code>JvmTransferRelation</code> to produce a successor in case of missing interprocedural call edge   (e.g., in case of incomplete call resolution).</li> <li>Fix call resolution for <code>invokedynamic</code> (issue #63). There might now be calls with incomplete target   information. By default, these calls will not be distributed to visitors, but this can be enabled   by setting the <code>skipIncompleteCalls</code> option in the call resolver.</li> <li>Fix leading <code>$</code> being stripped from inner classes by the <code>ClassReferenceFixer</code>. This prevents classes   with names like <code>Foo$$Bar</code> incorrectly having their simple name changed from <code>$Bar</code> to <code>Bar</code>.</li> </ul>"},{"location":"releasenotes.html#version-903","title":"Version 9.0.3","text":""},{"location":"releasenotes.html#java-support_1","title":"Java support","text":"<ul> <li>Update maximum supported Java class version to 63.65535 (Java 19 ea). (<code>PGD-247</code>)</li> </ul>"},{"location":"releasenotes.html#improved_9","title":"Improved","text":"<ul> <li>Add utility to produce dot-graphs for control flow automatons (<code>CfaUtil.toDot(cfa)</code>, example <code>VisualizeCfa</code>).</li> <li>Add support for heap slicing on call sites and heap reconstruction on return sites in dataflow analysis heap tree model.</li> <li>Add support for differential map representation to be used in the data flow analysis.</li> </ul>"},{"location":"releasenotes.html#api-improvements_3","title":"API Improvements","text":"<ul> <li>Split <code>ProgramLocationDependentTransferRelation</code> into forward and backward variants.</li> <li>Add <code>ClassPoolClassLoader</code> utility for loading ProGuardCORE classes.</li> <li>Add builders for CPA runs.</li> </ul>"},{"location":"releasenotes.html#version-902","title":"Version 9.0.2","text":""},{"location":"releasenotes.html#improved_10","title":"Improved","text":"<ul> <li><code>JvmMemoryLocationTransferRelation</code> does not rely anymore on a pre-computed abstract reachability graph.</li> </ul>"},{"location":"releasenotes.html#improvements-to-kotlin-metadata-initialization","title":"Improvements to Kotlin metadata initialization","text":"<p>Several improvements to Kotlin metadata initialization now allow building the Kotlin metadata model for library classes (<code>LibraryClass</code>):</p> <ul> <li><code>KotlinMetadataInitializer</code> provides a new public method <code>initialize(Clazz, int, int[], String[], String[], int, String, String)</code> to initialize   the Kotlin metadata model for a given class.</li> <li><code>ClassReader</code> can now build the Kotlin metadata model by setting <code>includeKotlinMetadata</code> to <code>true</code>.</li> <li><code>LibraryClassReader</code> can now read the Kotlin metadata annotation and provide the components to a consumer.</li> <li>An <code>UnsupportedKotlinMetadata</code> type is now assigned by the <code>KotlinMetadataInitializer</code> if the Kotlin metadata model   could not be initialized correctly. </li> </ul>"},{"location":"releasenotes.html#version-901","title":"Version 9.0.1","text":""},{"location":"releasenotes.html#improved_11","title":"Improved","text":"<ul> <li><code>ExecutingInvocationUnit</code> now loads values from static final fields.</li> <li>Initialize Kotlin lambda method references when the JVM method name is <code>&lt;anonymous&gt;</code>.</li> <li>Add the possibility of limiting the number of <code>CodeAttributes</code> contributing into CFA.</li> <li>Add the possibility of limiting the number of <code>CodeAttributes</code> considered by the <code>CallResolver</code>.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_6","title":"Bug fixes","text":"<ul> <li>Fix wrong handling of array types in <code>ExecutingIvocationUnit</code> and <code>ParticularReferenceValue</code>.</li> <li><code>ParticularReferenceValue</code> sanity checks now take inheritance into consideration, improving call analysis.</li> <li>Prevent missing semicolon leading to an infinite loop in <code>ClassUtil#internalMethodParameterCount</code>.</li> <li>Make category 2 CPA taint sources affect only the most significant byte abstract state.</li> <li>Fix inconsistent usage of type names in the context of the <code>PartialEvaluator</code> that could result in   trying to create an internal type string from a string that was already an internal type.</li> <li>Fix initialization of Kotlin callable references when using <code>-Xno-optimized-callable-references</code> compiler option.</li> <li>Fix <code>createCache()</code> delegation in <code>ArgBamCpaRun</code></li> </ul>"},{"location":"releasenotes.html#upgrade-considerations_1","title":"Upgrade considerations","text":""},{"location":"releasenotes.html#type-name-convention","title":"TYPE NAME CONVENTION","text":"<p>PGC has different representation for type string variables: </p> <ul> <li>External class name: <code>com.guardsquare.SomeClass</code></li> <li>Internal class name: <code>com/guardsquare/SomeClass</code></li> <li>Internal type (or just <code>type</code>): <code>Lcom/guardsquare/SomeClass;</code> (for arrays e.g. <code>[I</code>, <code>[Ljava/lang/Object;</code>)</li> <li>Internal class type: <code>com/guardsquare/SomeClass</code> (for arrays this is their internal type e.g. <code>[I</code>, <code>[Ljava/lang/Object;</code>)</li> </ul> <p>See <code>proguard.classfile.util.ClassUtil</code> for useful methods to convert between the different representations.</p> <p>Since internal class name and type were used ambiguously, from version 9.0.1 the internal type is used  consistently whenever we have a variable named <code>type</code>.</p> <p>Since this was not the case, this update might cause some <code>type</code> variables switching from the internal class name notation to the internal type notation, potentially breaking some logic if types are used by an external application using proguard-core.</p>"},{"location":"releasenotes.html#version-90-april-2022","title":"Version 9.0 (April 2022)","text":""},{"location":"releasenotes.html#configurable-program-analysis-cpa","title":"Configurable program analysis (CPA)","text":"<p>CPA is a formalism for data flow analysis allowing seamless composition of various analyses and model checking techniques. Thus, it adds a framework for systematic development and extension of static analyses in a uniform structured way.</p> <p>Taint analysis is the first ProGuardCORE CPA. Its goal is to detect data flow between source and sink method calls, which is useful for detecting bugs and security flaws.</p> <p>The Taint Analysis manual page provides more information.</p> <ul> <li>Add configurable program analysis (CPA) for interprocedural data flow analysis development.</li> <li>Add taint analysis.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_7","title":"Bug fixes","text":"<ul> <li>Prevent linking a final method with a shadowing method in a subclass.</li> <li>Force <code>Call#getArgumentCount()</code> to be correct even if the actual argument values   could not be calculated or have been cleared.</li> <li>Reset <code>ExecutingInvocationUnit</code> parameters array even when an exception happens.</li> </ul>"},{"location":"releasenotes.html#version-807","title":"Version 8.0.7","text":""},{"location":"releasenotes.html#java-support_2","title":"Java support","text":"<ul> <li>Update maximum supported Java class version to 62.65535 (Java 18 ea).</li> </ul>"},{"location":"releasenotes.html#improved_12","title":"Improved","text":"<ul> <li>Add support for Kotlin property synthetic delegate methods.</li> <li>Add ability to pass <code>KotlinMetadataVersion</code> to <code>KotlinMetadataWriter</code> / <code>KotlinModuleWriter</code>.</li> </ul>"},{"location":"releasenotes.html#version-806","title":"Version 8.0.6","text":""},{"location":"releasenotes.html#improved_13","title":"Improved","text":"<ul> <li>Add support for writing out zip64 archives.</li> <li>Improve speed for <code>ClassPool.contains</code> method.</li> </ul>"},{"location":"releasenotes.html#version-805","title":"Version 8.0.5","text":""},{"location":"releasenotes.html#improved_14","title":"Improved","text":"<ul> <li>Upgrade log4j2 dependency to v2.17.1 in response to CVE-2021-44832.</li> <li>Add support for reading and writing Kotlin 1.6 metadata.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_8","title":"Bug fixes","text":"<ul> <li>Fix <code>CallResolver</code> erroneously creating call edges to unimplemented interface methods.</li> <li>Make the <code>DominatorCalculator</code> skip methods with an empty <code>CodeAttribute</code>.</li> <li>Prevent updating Kotlin function names with mangled JVM method names in <code>ClassReferenceFixer</code>.</li> <li>Initialize Kotlin default implementation classes of annotation classes correctly in <code>ClassReferenceInitializer</code>.</li> <li>Correctly initialize Java Record component attributes in <code>ClassReferenceInitializer</code>.</li> </ul>"},{"location":"releasenotes.html#api-changes_5","title":"API changes","text":"<ul> <li><code>KotlinInterfaceToDefaultImplsClassVisitor</code> replaced by <code>KotlinClassToDefaultImplsClassVisitor</code>.</li> <li>Deprecate Kotlin class metadata flag <code>IS_INLINE</code> and replaced with <code>IS_VALUE</code>.</li> <li>Convert to/from Kotlin unsigned integers in Kotlin annotation unsigned type arguments.</li> <li>Initialize array dimension in Kotlin annotation <code>ClassValue</code> type arguments.</li> <li>Add support for Kotlin inline class underlying type to Kotlin metadata model.</li> <li>Add support to <code>MemberDescriptorReferencedClassVisitor</code> for visiting referenced Kotlin inline class parameters.</li> </ul>"},{"location":"releasenotes.html#version-804","title":"Version 8.0.4","text":""},{"location":"releasenotes.html#improved_15","title":"Improved","text":"<ul> <li>Upgrade log4j2 dependency to v2.17 in response to CVE-2021-45105.</li> </ul>"},{"location":"releasenotes.html#api-improvements_4","title":"API Improvements","text":"<ul> <li>Add <code>KotlinMetadataVersionFilter</code> to filter classes based on the version of the attached metadata.</li> </ul>"},{"location":"releasenotes.html#version-803","title":"Version 8.0.3","text":""},{"location":"releasenotes.html#improved_16","title":"Improved","text":"<ul> <li>Upgrade log4j2 dependency in response to CVE-2021-45046.</li> </ul>"},{"location":"releasenotes.html#version-802","title":"Version 8.0.2","text":""},{"location":"releasenotes.html#improved_17","title":"Improved","text":"<ul> <li>Upgrade log4j2 dependency in response to CVE-2021-44228.</li> </ul>"},{"location":"releasenotes.html#api-improvements_5","title":"API Improvements","text":"<ul> <li>Add call resolving and graph traversal features to enable interprocedural control flow analyses.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_9","title":"Bug fixes","text":"<ul> <li>Fix potential <code>StringIndexOutOfBoundsException</code> while trimming attribute value spaces in <code>SignedJarWriter</code>.</li> <li>Fix <code>referencedClass</code> of Values generated by the <code>ExecutingInvocationUnit</code>.</li> <li>Fix potential <code>StackOverflowError</code> when using an <code>AttributeVisitor</code> to visit runtime invisible type annotations.</li> <li>Fix potential <code>StringIndexOutOfBoundsException</code> in <code>KotlinCallableReferenceInitializer</code>.</li> <li>Fix potential <code>NullPointerException</code> in <code>KotlinInterClassPropertyReferenceInitializer</code>.</li> <li>Fix wrong offset for complementary branch instruction when widening branch instructions in <code>InstructionWriter</code>.</li> <li>Fix potential <code>ClassFormatError</code> due to adding multiple annotation attributes when processing Kotlin code.</li> <li>Fix potential <code>NullPointerException</code> due to missing classes in <code>ClassReferenceInitializer</code>.</li> <li>Prevent making package-private final methods that are shadowed protected.</li> </ul>"},{"location":"releasenotes.html#version-801","title":"Version 8.0.1","text":""},{"location":"releasenotes.html#api-improvements_6","title":"API Improvements","text":"<ul> <li>Add <code>LibraryClassBuilder</code> and <code>LibraryClassEditor</code> classes to create and edit a <code>LibraryClass</code>.</li> <li>Add additional constructors to <code>LibraryClass</code>. </li> </ul>"},{"location":"releasenotes.html#bug-fixes_10","title":"Bug fixes","text":"<ul> <li>Fix potential <code>NullPointerException</code> when initializing Kotlin callable references.</li> <li>Prevent requiring <code>--enable-preview</code> on a JVM for Java 16 class files (write class file version <code>60.0</code> instead of <code>60.65535</code>).</li> <li>Fix potential <code>NullPointerException</code> when visiting referenced methods of Kotlin functions.</li> </ul>"},{"location":"releasenotes.html#version-800","title":"Version 8.0.0","text":""},{"location":"releasenotes.html#java-support_3","title":"Java support","text":"<ul> <li>Update maximum supported Java class version to 61.0 (Java 17).</li> </ul>"},{"location":"releasenotes.html#kotlin-support_1","title":"Kotlin support","text":"<ul> <li>Add support for processing Kotlin 1.5 metadata.</li> <li>Update <code>kotlinx</code> metadata dependency to version 0.2.</li> </ul>"},{"location":"releasenotes.html#api-improvements_7","title":"API Improvements","text":"<ul> <li>Add <code>WarningLogger</code> class to allow using a custom Log4j2 logger.</li> <li>Add Kotlin metadata model classes and visitors for Kotlin annotations.</li> <li>Add Kotlin metadata model enum for <code>KmVariance</code>.</li> <li>Add Kotlin metadata model enum for <code>KmVersionRequirement(Kind|Level)</code>.</li> <li>Add Kotlin metadata model enum for <code>KmEffect(Type|InvocationKind)</code>.</li> <li>Add Kotlin metadata flag <code>IS_FUN</code> for functional interfaces.</li> <li>Add Kotlin metadata flag <code>HAS_NON_STABLE_PARAMETER_NAMES</code> for Kotlin callables.</li> <li>Add error handler callback to <code>KotlinMetadataInitializer</code>.</li> <li>Add error handler callback to <code>KotlinMetadataWriter</code>.</li> <li>Add error handler callback to <code>KotlinModuleReader</code>.</li> <li>Add error handler callback to <code>KotlinModuleWriter</code>. Add Kotlin metadata flag <code>IS_SECONDARY</code> for constructors.</li> <li>Implement <code>ClassVisitor</code> in <code>KotlinMetadataInitializer</code> to allow easier initialization of Kotlin metadata.</li> <li>Implement <code>ClassVisitor</code> in <code>KotlinMetadataWriter</code> to allow easier writing of Kotlin metadata.</li> </ul>"},{"location":"releasenotes.html#api-changes_6","title":"API changes","text":"<ul> <li><code>KotlinTypeParameterVistor#visitClassParameter(Clazz, KotlinMetadata, KotlinTypeParameterMetadata)</code> now has the correct signature: <code>KotlinTypeParameterVistor#visitClassParameter(Clazz, KotlinClassKindMetadata, KotlinTypeParameterMetadata)</code>. </li> <li>Rename <code>AllKotlinPropertiesVisitor</code> to <code>AllPropertyVisitor</code>.</li> <li>Rename <code>AllConstructorsVisitor</code> to <code>AllConstructorVisitor</code>.</li> <li>Rename <code>AllFunctionsVisitor</code> to <code>AllFunctionVisitor</code>.</li> <li>Remove `KotlinValueParameterVisitor.onNewFunctionStart()' method.</li> <li>Deprecate Kotlin metadata flag <code>IS_PRIMARY</code> for constructors.</li> </ul>"},{"location":"releasenotes.html#version-711","title":"Version 7.1.1","text":""},{"location":"releasenotes.html#api-improvements_8","title":"API improvements","text":"<ul> <li>Add <code>KotlinTypeParameterFilter</code> to allow filtering easily when visiting type parameters.</li> <li>Add <code>KotlinValueParameterFilter</code> to allow filtering easily when visiting value parameters.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_11","title":"Bug fixes","text":"<ul> <li>Fix <code>AllTypeParameterVisitor</code> so that it visits type parameters defined in any kind of declaration container.</li> <li>Fix <code>AllTypeParameterVisitor</code> so that it visits type parameters of type aliases.</li> <li>Fix potential <code>NullPointerException</code> when initializing a Kotlin default implementation class that does not contain an initialized <code>jvmSignature</code>.</li> <li>Add missing <code>equals</code> method to <code>ParticularReferenceValue</code>.</li> <li>Fix incorrect handling of <code>InterruptedException</code> in <code>ParallelAllClassVisitor</code>.</li> <li>Fix potential <code>ZipOutput</code> alignment issue when writing large uncompressed zip entries.</li> <li>Fix potential <code>ZipOutput</code> synchronization issue when writing uncompressed zip entries.</li> <li>Fix potential <code>NullPointerException</code> when comparing strings with <code>FixedStringMatcher</code>.</li> <li>Fix potential <code>NullPointerException</code> when comparing strings with <code>MatchedStringMatcher</code>.</li> <li>Fix initialization of Kotlin callable references when using Kotlin &gt;= 1.4.</li> </ul>"},{"location":"releasenotes.html#version-71-june-2021","title":"Version 7.1 (June 2021)","text":""},{"location":"releasenotes.html#java-support_4","title":"Java support","text":"<p>ProGuardCORE 7.1 now supports Java versions 14, 15 and 16:</p> <ul> <li>Add support for reading &amp; writing Java 14, 15 and 16 class files.</li> <li>Add support for Java 14 sealed classes (permitted subclasses attributes).</li> <li>Add support for record attributes (previewed in Java 15/16, targeted for Java 17).</li> </ul>"},{"location":"releasenotes.html#improved-code-analysis","title":"Improved code analysis","text":"<ul> <li>The partial evaluator can now be used to reconstruct the specific values of <code>String</code>, <code>StringBuilder</code> and <code>StringBuffer</code> type objects.    See analyzing code manual page for more information.</li> <li>The partial evaluator will now throw an <code>IncompleteClassHierarchyException</code> instead of   <code>IllegalArgumentException</code> when an incomplete hierarchy is encountered.</li> <li>The partial evaluator will now throw an <code>ExcessiveComplexityException</code> if an instruction is visited more than <code>stopAnalysisAfterNEvaluations</code> times.</li> <li>Potentially throwing <code>ldc</code> instructions are now taken into account during partial evaluation,   improving the accuracy of code analysis.</li> <li>Add support for multiple possible types during partial evaluation.</li> </ul>"},{"location":"releasenotes.html#performance-improvements","title":"Performance improvements","text":"<ul> <li>Improve efficiency of building classes, methods and constant pools.</li> </ul>"},{"location":"releasenotes.html#api-improvements_9","title":"API improvements","text":"<ul> <li>Add <code>ClassRenamer</code> to allow renaming classes and members easily.</li> </ul>"},{"location":"releasenotes.html#bug-fixes_12","title":"Bug fixes","text":"<ul> <li>Add missing method reference in injected static initializer instructions.</li> <li>Add missing dimensions argument to <code>CompactCodeAttributeComposer.multianewarray</code>.</li> <li>Fix potential <code>StackOverflowException</code> when comparing multi-typed reference values.</li> <li>Fix handling of Kotlin nested class names which contain <code>$</code>.</li> <li>Mark <code>Module</code>, <code>ModuleMainClass</code> and <code>ModulePackages</code> attributes as required.</li> <li>Fix potential <code>ClassCastException</code> in <code>ConstructorMethodFilter</code>.</li> <li>Fix potential <code>NullPointerException</code> for module classes in ClassPrinter.</li> <li>Fix storage and alignment of uncompressed zip entries.</li> <li>Fix processing of constant boolean arrays.</li> <li>Fix adding branch instructions with labels in <code>CompactCodeAttributeComposer</code>.</li> <li>Fix handling of array dereferencing in <code>MultiTypedReferenceValue</code>.</li> <li>Fix <code>AllKotlinAnnotationVisitor</code> so that it visits type alias annotations defined in any kind of declaration container.</li> <li>Move initialization of Kotlin declaration container's <code>ownerClassName</code> field from <code>ClassReferenceInitializer</code> to <code>KotlinMetadataInitializer</code>.</li> </ul>"},{"location":"releasenotes.html#version-70-jan-2020","title":"Version 7.0 (Jan 2020)","text":"Version Issue Module Explanation 7.0.1 DGD-2382 CORE Fixed processing of Kotlin 1.4 metadata annotations. 7.0.1 DGD-2390 CORE Fixed storage and alignment of uncompressed zip entries. 7.0.1 DGD-2338 CORE Fixed processing of constant boolean arrays. 7.0.1 CORE Fixed adding branch instructions with labels in CompactCodeAttributeComposer. 7.0.0 CORE Initial release of Kotlin support. 7.0.0 PGD-32 CORE Added support for Java 14 class files. 7.0.0 DGD-1780 CORE Removed dependency on internal sun.security API. 7.0.0 DGD-1800 CORE Fixed obfuscation of functional interfaces with abstract Object methods. 7.0.0 CORE Initial release, extracted from ProGuard."},{"location":"taintcpa.html","title":"Taint analysis with CPA","text":""},{"location":"taintcpa.html#taint-analysis-with-cpa","title":"Taint analysis with CPA","text":"<p>Taint analysis aims for detecting a data flow between taint sources and sinks. Configurable program analysis (CPA) is a formalism suitable for integrating multiple data flow analyses in one tool. Taints can be traced in few simple steps.</p>"},{"location":"taintcpa.html#modeling-the-control-flow","title":"Modeling the control flow","text":"<p>A control flow automaton (CFA) is a graph with nodes being bytecode offsets and edges being instructions or calls connecting them. You can create a CFA from the program class pool:</p> <pre><code>// Create the control flow automaton (CFA).\nJvmCfa cfa = CfaUtil.createInterproceduralCfaFromClassPool(programClassPool);\n</code></pre>"},{"location":"taintcpa.html#defining-taint-sources","title":"Defining taint sources","text":"<p>Every taint analysis data flow starts from a taint source. Any Java method can be a taint source. You have several options of how a taint source can behave. A source may:</p> <ul> <li>taint the calling instance,</li> <li>return the taint,</li> <li>taint its actual parameters of nonprimitive types,</li> <li>taint static fields.</li> </ul> <p>For creating a taint you need its fully qualified name and the expected tainting pattern. Let us create a simple taint source returning a tainted string:</p> <pre><code>// Create a taint source.\nTaintSource source = new TaintSource(\"LMain;source()Ljava/lang/String;\", // the fully qualified name of a source method\nfalse,                              // whether the source taints the calling instance\ntrue,                               // whether the source taints its return\nCollections.emptySet(),             // a set of tainted arguments\nCollections.emptySet());            // a set of tainted global variables\n</code></pre>"},{"location":"taintcpa.html#defining-taint-sinks","title":"Defining taint sinks","text":"<p>Taint sinks are the counterpart of taint sources sensitive to a taint. A taint sink may be sensitive to</p> <ul> <li>the calling instance,</li> <li>actual parameters,</li> <li>static fields.</li> </ul> <p>Given the fully qualified name and the sensitivity model you can straightforwardly create a taint sink like the one sensitive to its only argument:</p> <pre><code>// Create a taint sink.\nJvmTaintSink sink = new JvmTaintSink(\"LMain;sink(Ljava/lang/String;)V\", // the fully qualified name of a sink method\nfalse,                             // whether the sink is sensitive to the calling instance\nCollections.singleton(1),          // a set of sensitive arguments\nCollections.emptySet());           // a set of sensitive global variables\n</code></pre> <p>Note: The argument enumeration for both taint sources and taint sinks starts from one and does not depend on whether the method is static. The calling distance is handled by a separate boolean constructor parameter.</p>"},{"location":"taintcpa.html#setting-up-a-cpa-run","title":"Setting up a CPA run","text":"<p>CPA runs encapsulate the initialization of CPA components and allow configuring the analysis. The CPA run needs to know in which method the analysis needs to start and how deep the call stack for the interprocedural analysis should be. All calls overflowing the stack, as well as all library methods, are approximated intraprocedurally as propagating the taint from their calling instance and arguments into the return value. You can create a CPA run for analyzing <code>Main.main(String args)</code> with an unlimited call stack as follows:</p> <pre><code>// Create the CPA run.\nJvmTaintMemoryLocationBamCpaRun cpaRun = new JvmTaintMemoryLocationBamCpaRun(cfa,                                          // a CFA\nCollections.singleton(source),                // a set of taint sources\nnew MethodSignature(\"Main\",\n\"main\",\n\"([Ljava/lang/String)V\"), // the signature of the main method\n-1,                                           // the maximum depth of the call stack analyzed interprocedurally.\n// 0 means intra-procedural analysis.\n// &lt; 0 means unlimited depth.\nTaintAbstractState.bottom,                    // a cut-off threshold\nCollections.singleton(sink));                 // a collection of taint sinks\n</code></pre>"},{"location":"taintcpa.html#running-the-analysis-and-obtaining-witness-traces","title":"Running the analysis and obtaining witness traces","text":"<p>The analysis execution can be done in a single line together with generating witness traces:</p> <pre><code>// Run the analysis and get witness traces.\nSet&lt;List&lt;JvmMemoryLocation&gt;&gt; traces = cpaRun.extractLinearTraces();\n</code></pre>"},{"location":"taintcpa.html#interpreting-the-analysis-result","title":"Interpreting the analysis result","text":"<p>The result of the analysis is a set of witness traces, if there is a data flow detected. A witness trace is a list of memory locations at specific program locations. For instance, the class below</p> <pre><code>// Run the analysis and get witness traces.\npublic class Main\n{\npublic static void main()\n{\nsink(callee());\n}\n\npublic static String callee()\n{\nreturn source();\n}\n}\n</code></pre> <p>would generate a witness trace consisting of two top stack locations, one after the taint source in <code>callee()</code> and another before the call to <code>sink(String s)</code>:</p> <pre><code>[JvmStackLocation(0)@LMain;main()V:3, JvmStackLocation(0)@LMain;callee()Ljava/lang/String;:3]\n</code></pre> <p>Note that the traces returned by the CPA run go from the taint sink to the taint source. There are four types of memory locations:</p> <ul> <li>stack locations identified by their offsets from the operand stack top,</li> <li>local variable locations identified by their indices in the local variable array,</li> <li>static field locations identified by their fully qualified names,</li> <li>heap locations identified by their abstract references.</li> </ul> <p>Complete example: AnalyzeTaints.java</p>"}]}